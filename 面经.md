####1、position都有些什么属性，具体说一下每个属性
  >·static：静态定位，表示无论怎么设置top、bottom、right、left属性元素的位置（与外部位置）都不会发生改变
  ·fixed：相对于浏览器窗口进行定位，同样是使用top、bottom、right、left
  ·relative：相对定位，表示用top、bottom、right、left属性可以设置元素相对与其相对于初始位置的相对位置
  ·absolute：绝对定位，表示用top、bottom、right、left属性可以设置元素相对于其父元素（除了设置了static的父元素以外）左上角的位置，如果父元素设置了static，子元素会继续追溯到祖辈元素一直到body
  （即一直找祖先，直到找到第一个positon不是默认值的祖先元素）

####2.flex布局，都有什么属性
>flex-direction  属性设置容器主轴的方向
flex-wrap 用于设置当项目在容器中一行无法显示的时候如何处理  
flew-flow flex-flow属性是flex-deriction和flex-wrap属性的简写，默认值为[row nowrap]
justify-content justify-content属性用于设置项目在容器中的对齐方式
align-items align-items定义了项目在交叉轴上是如何对齐显示的
align-content 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用
#####以下六个属性设置在子元素上
>order 定义项目的排列顺序。数值越小，排列越靠前，默认为0
          flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大
          flex-shrink 属性定义了项目的缩小比例，默认为1
          flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。 默认auto
          flex flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选  flex:1 就是grow1,会填充空间,其余默认
          align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。          
####3css画三角形的原理

  首先创建一个div元素，设置div的width和height为0，只用边框宽来填充，边框样式设置为实线“solid”；然后顶部边框设置颜色，剩下的三个边框的颜色设置为透明“transparent”值即可

      `.trangle{

    　　width: 0px;

    　　height: 0px;

    　　border-top: 100px solid red;

    　　border-left: 100px solid transparent;

    　　border-right: 100px solid transparent;

    }

    <div class="trangle"></div>`

####4.跨域
>所谓同源是指"协议+域名+端口"三者相同
跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了
#####1.CORS
>CORS 需要浏览器和后端同时支持
服务端设置 Access-Control-Allow-Origin 就可以开启 CORS

#####2.代理
实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤

>接受客户端请求 。
将请求 转发给服务器。
拿到服务器 响应 数据。
将 响应 转发给客户端。

#####3.JSONP
>利用 script标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据
>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击

####5.let const 和var
#####var

>var用于声明一个函数范围或者全局范围的变量
>var的所声明的变量并不是声明在块级作用域中 ，而是声明在最近的函数上下文中，也就是局部函数作用域。对于未在任何函数中声明的变量，其声明范围则是在全局对象global之中
>var的变量声明支持在同一作用域中进行同一个变量的多次重复的声明
>var的变量声明存在“提升”（hoisting）的特性
>变量的声明在执行时被提升了，但是，变量声明中的初始赋值操作却并没有被提升

#####let const

>带来我们的第一个让人兴奋的特性就是块级作用域
>不可重复声明
>暂时性死区 在代码执行上约束了变量必须遵循“声明后才能使用”的原则

#####let和const的区别
简单来说，let和const的区别在于，let用于声明基于块级作用域的变量，而const用于声明基于块级作用域的常量。

>使用let声明的变量，在变量的整个生命周期中，能够对变量随时进行赋值修改。
>使用const声明的变量为引用常量，必须在声明的同时进行初始赋值，在变量的整个生命周期中，无法再通过赋值的方式来修改变量值。

const的这个无法再赋值的特性，在不同的变量类型下会有不同的表现：

>1.如果const声明并且初始化赋值是基础数据类型变量（String、Number、Boolean、Symbol），那么该变量之后就不能再进行任何值的修改了。因为基础数据类型变量的值必须通过变量赋值来进行修改。
>2.如果const声明并且初始化赋值是引用数据类型变量（Array、Object、Map、Set），那么我们则可以随意对该变量的字段属性进行修改。因为引用数据类型变量的内容修改（新增、修改、删除属性）并不会出现所声明变量的赋值操作.

####6.箭头函数
>1.声明一个普通函数需要使用关键字function来完成，并且使用function既可以声明成一个具名函数也可以声明成一个匿名函数
>2.声明一个箭头函数则只需要使用箭头就可以，无需使用关键字function，比普通函数声明更简洁。
>3.箭头函数只能声明成匿名函数，但可以通过表达式的方式让箭头函数具名

- 箭头函数没有自己的this，而是引用的上层作用域中this
- 箭头函数的this永远不会变，call、apply、bind也无法改变
>我们可以用call、apply、bind来改变普通函数的this指向，但是由于箭头函数的this指向在它定义时就已经确定了，永远指向它定义时的上层作用域中的this，所以使用这些方法永远也改变不了箭头函数this的指向

- 箭头函数没有原型prototype

- 箭头函数不能当成一个构造函数
  1. 新建一个空对象

  2. 链接到原型

  3. 绑定this，执行构造函数

  4. 返回新对象


          function myNew() {
          // 1.新建一个空对象
          let obj = {}
          // 2.获得构造函数
          let con = arguments.__proto__.constructor
          // 3.链接原型
          obj.__proto__ = con.prototype
          // 4.绑定this，执行构造函数
          let res = con.apply(obj, arguments)
          // 5.返回新对象
          return typeof res === 'object' ? res : obj
          }


####7.margin塌陷问题如何解决，BFC，如何触发BFC
>块的上外边距(margin-top)和下外边距(margin-bottom)有时合并(折叠)为单个边距，其大小为单个边距的最大值(或如果它们相等，则仅为其中一个)，这种行为称为外边距折叠。

#####如何计算
>+ 同正或同负，取绝对值最大的
>+ 不同符号，取最大与最小值之和 70px + (-20px)

#####BFC，如何触发BFC
>BFC 全称：Block Formatting Context， 名为 "块级格式化上下文"
>简单来说就是，BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局

#####触发BFC

- 根元素（html）
- 浮动元素（float 值不为 none）
- 绝对定位元素（position 值为 absolute 或 fixed）
- 行内块元素（display 值为 inline-block）
- 表格单元格（display 值为 table-cell，HTML 表格单元格默认值）
- 表格标题（display 值为 table-caption，HTML 表格标题默认值）
- 匿名表格单元格元素（display 值为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、tr、tbody、thead、tfoot 的默认值）或 inline-table）
- overflow 值不为 visible、clip 的块元素
- display 值为 flow-root 的元素
- contain 值为 layout、content 或 paint 的元素
- 弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器
- 网格元素（display 值为 grid 或 inline-grid 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器
- 多列容器（column-count 或 column-width (en-US) 值不为 auto，包括column-count 为 1）
- column-span 值为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中 (规范变更, Chrome bug)

####8.那些属性可以继承呢
字体系列

>font
font-family
font-weight
font-size
font-style
font-variant: small-caps; 所有小写字母转成大写字母，但是与其他文本相比尺寸更小



文本系列

>text-indent
text-align
line-height
word-spacing
letter-spacing: 字符间距
text-transform: capitalize; 转大写 lowercase; 转小写
direction：文字方向
color



元素可见性

>visibility



表格布局

>border-collapse
border-spacing
empty-cell



列表布局

>list-style-type
list-style-image
list-style-position
list-style

####9.有哪些选择器，优先级如何
- id选择器
- 类选择器
- 标签选择器
- 通配符
- 后代选择器  定义的时候用空格隔开
  
      .div1 p{
                color:red;
            }
- 伪类选择器
- 伪元素选择器
- 交集选择器  必须是h3标签，然后必须是special标签
- 并集选择器  三种基本选择器都可以放进来
- E:nth-child(n) E:first-child E:last-child
 

#####优先级
!important>行内样式>id选择器>class、属性、伪类>标签、伪元素>通配符

####10、设置宽度的width：50%是相对于谁而言，font-size:10%相对谁而言？
1.相对于父元素 2.相对于父节点的字体大小的相对大小

####11.px,em,rem
>px就是像素，也是我们现在经常使用的基本单位
>em参考物是当前标签的font-size，默认字体大小是16px，所以1em不是固定值，为什么大多数情况下都说是父元素的font-size，是因为多数情况下字体大小都是从父元素继承，如果给当前标签设置一个单独的font-size，em就会改变
rem相对于根元素的大小 一般浏览器默认是16px，所以1rem往往就是16px

####13.判断数组的方法
Array.isArray()，instanceof,Object.prototype.toString.call()
>每一个继承Object的对象都有toString方法，如果toString方法没有重写的话，会返回[Object type],其中type为对象的类型，但当除了Object类型的对象外，其他类型直接使用toString方法时，会直接返回都是内容的字符串，所以需要使用call或者apply方法来改变toString方法的执行上下文。对于所有基本的数据类型都能进行判断，即使是null和undefined.

####14.什么是伪数组？如何转化为真正的数组？
1. 具有length属性，可以获取长度。
2. 具有索引，可以通过遍历获取所有元素。
3. 不可以使用数组的内置方法和属性。

>伪数组的__proto__指向的是一个Object对象
真数组的__proto__指向的是一个Array数组
自然就不能使用数组的的方法

#####常见的伪数组
1. 函数的内置对象arguments，它是所有实参组成的伪数组。
2. DOM对象组成的伪数组，通过document.querySelectorAll等获得的dom对象列表。

如何转化
1. 最简单的，先准备一个新的空数组，然后遍历伪数组，将伪数组中的值通过索引逐个添加到新数组当中
2. 利用扩展运算符(...)将伪数组转化为真数组 - ES6语法

        let divs = document.querySelectorAll('div');
        let arr = [...divs];

3. 利用Array的原型对象的slice方法，配合call()方法修改slice中this指向
   
        let arr = [].slice.call(divs);
4. 利用Array.from方法 - ES6

        let arr = Array.from(divs);