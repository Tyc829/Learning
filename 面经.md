### 1、position都有些什么属性，具体说一下每个属性
  >- static：静态定位，表示无论怎么设置top、bottom、right、left属性元素的位置（与外部位置）都不会发生改变
  >- fixed：相对于浏览器窗口进行定位，同样是使用top、bottom、right、left
  >- relative：相对定位，表示用top、bottom、right、left属性可以设置元素相对与其相对于初始位置的相对位置
  >- absolute：绝对定位，表示用top、bottom、right、left属性可以设置元素相对于其父元素（除了设置了static的父元素以外）左上角的位置，如果父元素设置了static，子元素会继续追溯到祖辈元素一直到body
  （即一直找祖先，直到找到第一个positon不是默认值的祖先元素）

### 2.flex布局，都有什么属性
>flex-direction  属性设置容器主轴的方向
flex-wrap 用于设置当项目在容器中一行无法显示的时候如何处理  
flew-flow flex-flow属性是flex-deriction和flex-wrap属性的简写，默认值为[row nowrap]
justify-content justify-content属性用于设置项目在容器中的对齐方式
align-items align-items定义了项目在交叉轴上是如何对齐显示的
align-content 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用
##### 以下六个属性设置在子元素上
>- order 定义项目的排列顺序。数值越小，排列越靠前，默认为0
- flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大
- flex-shrink 属性定义了项目的缩小比例，默认为1
- flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。 默认auto
- flex flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选  flex:1 就是grow1,会填充空间,其余默认
- align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。          
#### 3css画三角形的原理

  首先创建一个div元素，设置div的width和height为0，只用边框宽来填充，边框样式设置为实线“solid”；然后顶部边框设置颜色，剩下的三个边框的颜色设置为透明“transparent”值即可

      `.trangle{
    
    　　width: 0px;
    
    　　height: 0px;
    
    　　border-top: 100px solid red;
    
    　　border-left: 100px solid transparent;
    
    　　border-right: 100px solid transparent;
    
    }
    
    <div class="trangle"></div>`

### 4.跨域
>所谓同源是指"协议+域名+端口"三者相同
>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了
##### 1.CORS
>CORS 需要浏览器和后端同时支持
>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS
>
>就是在options方法的请求添加 Access-Control-Allow-Origin的

当一个请求跨域而且不是简单请求是就会发送option，也就是预请求。不满足简单请求时，会使用 **options** 方法发起一个 **预检请求（Preflight）** 到服务器，以获知服务器是否允许该实际请求

以下为简单请求

- 请求方法为：**GET** 、**POST** 、 **HEAD**
- 请求头：**Accept**、**Accept-Language**、**Content-Language**、**Content-Type**

##### 2.代理
实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤

>接受客户端请求 。
将请求 转发给服务器。
拿到服务器 响应 数据。
将 响应 转发给客户端。

##### 3.JSONP
>利用 script标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据
>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击

### 5.let const 和var
##### var

>var用于声明一个函数范围或者全局范围的变量
>var的所声明的变量并不是声明在块级作用域中 ，而是声明在最近的函数上下文中，也就是局部函数作用域。对于未在任何函数中声明的变量，其声明范围则是在全局对象global之中
>var的变量声明支持在同一作用域中进行同一个变量的多次重复的声明
>var的变量声明存在“提升”（hoisting）的特性
>变量的声明在执行时被提升了，但是，变量声明中的初始赋值操作却并没有被提升

##### let const

>带来我们的第一个让人兴奋的特性就是块级作用域
>不可重复声明
>暂时性死区 在代码执行上约束了变量必须遵循“声明后才能使用”的原则

##### let和const的区别
简单来说，let和const的区别在于，let用于声明基于块级作用域的变量，而const用于声明基于块级作用域的常量。

>使用let声明的变量，在变量的整个生命周期中，能够对变量随时进行赋值修改。
>使用const声明的变量为引用常量，必须在声明的同时进行初始赋值，在变量的整个生命周期中，无法再通过赋值的方式来修改变量值。

const的这个无法再赋值的特性，在不同的变量类型下会有不同的表现：

>1.如果const声明并且初始化赋值是基础数据类型变量（String、Number、Boolean、Symbol），那么该变量之后就不能再进行任何值的修改了。因为基础数据类型变量的值必须通过变量赋值来进行修改。
>2.如果const声明并且初始化赋值是引用数据类型变量（Array、Object、Map、Set），那么我们则可以随意对该变量的字段属性进行修改。因为引用数据类型变量的内容修改（新增、修改、删除属性）并不会出现所声明变量的赋值操作.

### 6.箭头函数
>1.声明一个普通函数需要使用关键字function来完成，并且使用function既可以声明成一个具名函数也可以声明成一个匿名函数
>2.声明一个箭头函数则只需要使用箭头就可以，无需使用关键字function，比普通函数声明更简洁。
>3.箭头函数只能声明成匿名函数，但可以通过表达式的方式让箭头函数具名

- 箭头函数没有自己的this，而是引用的上层作用域中this
- 箭头函数的this永远不会变，call、apply、bind也无法改变
>我们可以用call、apply、bind来改变普通函数的this指向，但是由于箭头函数的this指向在它定义时就已经确定了，永远指向它定义时的上层作用域中的this，所以使用这些方法永远也改变不了箭头函数this的指向

- 箭头函数没有原型prototype

- 箭头函数不能当成一个构造函数
  1. 新建一个空对象

  2. 链接到原型

  3. 绑定this，执行构造函数

  4. 返回新对象


          function myNew() {
          // 1.新建一个空对象
          let obj = {}
          // 2.获得构造函数
          let con = arguments.__proto__.constructor
          // 3.链接原型
          obj.__proto__ = con.prototype
          // 4.绑定this，执行构造函数
          let res = con.apply(obj, arguments)
          // 5.返回新对象
          return typeof res === 'object' ? res : obj
          }


### 7.margin塌陷问题如何解决，BFC，如何触发BFC
>块的上外边距(margin-top)和下外边距(margin-bottom)有时合并(折叠)为单个边距，其大小为单个边距的最大值(或如果它们相等，则仅为其中一个)，这种行为称为外边距折叠。

作用：两栏布局，清楚内部浮动，解决margn塌陷

##### 如何计算
>+ 同正或同负，取绝对值最大的
>+ 不同符号，取最大与最小值之和 70px + (-20px)

##### BFC，如何触发BFC
>BFC 全称：Block Formatting Context， 名为 "块级格式化上下文"
>简单来说就是，BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局

##### 触发BFC

- 根元素（html）
- 浮动元素（float 值不为 none）
- 绝对定位元素（position 值为 absolute 或 fixed）
- 行内块元素（display 值为 inline-block）
- 表格单元格（display 值为 table-cell，HTML 表格单元格默认值）
- 表格标题（display 值为 table-caption，HTML 表格标题默认值）
- 匿名表格单元格元素（display 值为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、tr、tbody、thead、tfoot 的默认值）或 inline-table）
- overflow 值不为 visible、clip 的块元素
- display 值为 flow-root 的元素
- contain 值为 layout、content 或 paint 的元素
- 弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器
- 网格元素（display 值为 grid 或 inline-grid 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器
- 多列容器（column-count 或 column-width (en-US) 值不为 auto，包括column-count 为 1）
- column-span 值为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中 (规范变更, Chrome bug)

### 8.那些属性可以继承呢
字体系列

>font
font-family
font-weight
font-size
font-style
font-variant: small-caps; 所有小写字母转成大写字母，但是与其他文本相比尺寸更小



文本系列

>text-indent
text-align
line-height
word-spacing
letter-spacing: 字符间距
text-transform: capitalize; 转大写 lowercase; 转小写
direction：文字方向
color



元素可见性

>visibility



表格布局

>border-collapse
border-spacing
empty-cell



列表布局

>list-style-type
list-style-image
list-style-position
list-style

### 9.有哪些选择器，优先级如何
- id选择器
- 类选择器
- 标签选择器
- 通配符
- 后代选择器  定义的时候用空格隔开
  
      .div1 p{
                color:red;
            }
- 伪类选择器
- 伪元素选择器
- 交集选择器  必须是h3标签，然后必须是special标签
- 并集选择器  三种基本选择器都可以放进来
- E:nth-child(n) E:first-child E:last-child
- 前三个（-n+3） 3到6 E:nth-child(-n+6):nth-child(n+3)


##### 优先级
!important>行内样式>id选择器>class、属性、伪类>标签、伪元素>通配符

### 10、设置宽度的width：50%是相对于谁而言，font-size:10%相对谁而言？
1.相对于父元素 2.相对于父节点的字体大小的相对大小

#### 11.px,em,rem
>px就是像素，也是我们现在经常使用的基本单位
>em参考物是当前标签的font-size，默认字体大小是16px，所以1em不是固定值，为什么大多数情况下都说是父元素的font-size，是因为多数情况下字体大小都是从父元素继承，如果给当前标签设置一个单独的font-size，em就会改变
rem相对于根元素的大小 一般浏览器默认是16px，所以1rem往往就是16px

### 13.判断数组的方法
Array.isArray()，instanceof,Object.prototype.toString.call() arr instanceof Array
>每一个继承Object的对象都有toString方法，如果toString方法没有重写的话，会返回[Object type],其中type为对象的类型，但当除了Object类型的对象外，其他类型直接使用toString方法时，会直接返回都是内容的字符串，所以需要使用call或者apply方法来改变toString方法的执行上下文。对于所有基本的数据类型都能进行判断，即使是null和undefined.

##### 补充 instanceof 原理
查找原型链

        function myInstanceof(left, right) {
          let proto = Object.getPrototypeOf(left)
          let prototype = right.prototype
          while (true) {
            if (!proto) return false
            if (proto == prototype) return true
            proto = Object.getPrototypeOf(proto)
          }
        }

### 14.什么是伪数组？如何转化为真正的数组？
1. 具有length属性，可以获取长度。
2. 具有索引，可以通过遍历获取所有元素。
3. 不可以使用数组的内置方法和属性。

>伪数组的__proto__指向的是一个Object对象
真数组的__proto__指向的是一个Array数组
自然就不能使用数组的的方法

##### 常见的伪数组
1. 函数的内置对象arguments，它是所有实参组成的伪数组。
2. DOM对象组成的伪数组，通过document.querySelectorAll等获得的dom对象列表。

如何转化
1. 最简单的，先准备一个新的空数组，然后遍历伪数组，将伪数组中的值通过索引逐个添加到新数组当中
2. 利用扩展运算符(...)将伪数组转化为真数组 - ES6语法

        let divs = document.querySelectorAll('div');
        let arr = [...divs];

3. 利用Array的原型对象的slice方法，配合call()方法修改slice中this指向
   
        let arr = [].slice.call(divs);
4. 利用Array.from方法 - ES6

        let arr = Array.from(divs);

### 15.事件绑定的三种方式
1. 在DOM中绑定
2. 在JS代码中绑定 document.getElementById("demo").onclick=function(){}
3. 通过事件监听函数绑定
   
        document.getElementById(元素id).addEventListener("click", function(){
                        console.log("目标元素被点击了");
        });

#### addeventlistener几个参数，第三个参数什么意思
3个，第一个是事件名称，字符串，必填 onclick keyup keydown
第二个是执行函数，会传入一个事件参数，可以用event接收 click对应MouseEvent事件
第三个是触发类型 布尔值   true 捕获阶段执行 冒泡阶段执行 默认false 也可以传递一个对象

addEventListener可以对同一个元素绑定多个事件，执行顺序按照绑定时的顺序，从上到下依次执行。而onclick同一个元素只能绑定一个事件，如有多个，后面的事件会覆盖前面的事件。
注册addEventListener事件时不需要写on，而onclick方式则必须加on
在移除事件上，onclick使用的是指针指向null，例如document.onclick = null，而addEventListener则使用的是独有的移除方法removeEventListener

###    16.js基本数据类型
 Number，布尔，null，string，symbol（符号），undefined,bigint

typeof可以判断除null以外的所有基本类型（null）是对象  数组和对象是object ，函数是function
Object.prototype.toString.call  返回 [object Number]等形式

基本数据类型放在栈里  
引用数据类型放在堆里

##### 数据类型为什么要分堆和栈
>栈不能适应可变大小、分配时间和数目是动态的存储，因此需要堆。但同时堆耗费的性能较高，因此对于数据解构固定的变量最好还是放在栈里。
堆可以取代栈，但是影响性能

###    17.null和undefine区别
- 都是基本数据类型，都只有一个值
- 前者表示空对象，后者表示为定义
- 一般变量声明了但是没有定义会返回undefined，null可以用来初始化
- typeof null 会返回对象
- 双等号返回true 三等号返回false

null+1 = 1
undefined+1 = nan not a number

###  18.typeof NaN 返回number

###  19.判断浏览器类型操作系统
- 代理检测
- navigator.userAgent 可以检查

### 20.HTTP状态码（小林背常见的）

### 21.样式选择器有哪几种
- 标签选择器
- 类选择器 .
- id选择器 #
- 派生选择器 div h1 嵌套关系
- 组合选择器 多种标签类id有相同的样式

### 22.从输入URL到页面加载发生什么

1. 解析URL 分析需要使用的传输协议和请求资源的路径等等
2. 判断缓存 如果缓存中存在请求的资源，那么就会直接返回，否则就要向服务器发送请求
3. 进行DNS解析，将URL解析为IP地址
4. TCP三次握手建立连接
5. 发送HTTP请求
6. 服务端接收HTTP请求并根据请求做出响应
7. 浏览器渲染页面
8. 四次挥手断开连接


### 23.解析html过程中遇到静态资源请求会不会阻塞？
会，浏览器有最高并发限制，请求过多就会引起阻塞

### 24.Css树会影响页面渲染的速度吗？
不会影响dom树的解析，但会影响dom树的渲染
详情看浏览器的渲染

### 25.浏览器的渲染
>HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)根据Render Tree渲染绘制，将像素渲染到屏幕上
>>DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。
然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。
>>>由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。

1. js在任何时候都会阻塞dom,通常是将js放在body结束的时候，这样会将所页面渲染完成之后再执行js。有利于用户的体验。async是异步加载js，加载完成立刻执行。defer是异步加载js，但是加载完成之后会等待一个事件dom解析完成之后执行。
2. css的加载会阻塞js的执行，会阻塞页面的渲染，但是不会阻塞DOM的解析。


### 26.浏览器的垃圾回收
1. 为什么需要垃圾回收
程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃

2. 垃圾回收策略
    >标记清除：此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁
    1. 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
    2. 然后从各个根对象开始遍历，把不是垃圾的节点改成1
    3. 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
    4. 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

    标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题  而且分配速度慢


    标记整理：标记升级的改进，在标记结束之后，会将活着的对象向内存的一端移动，最后清理道边界的内存


    引用计数：
    >跟踪记录每个变量值被使用的次数
    1. 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
    2. 如果同一个值又被赋给另一个变量，那么引用数加 1
    3. 如果该变量的值被其他的值覆盖了，则引用次数减 1
    4. 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存
    缺点，循环引用不会被清除
    标记清除需要每隔一段事件进行一次

##### V8的垃圾回收原理
>>V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收
新生代区域将堆内存一分为二，一个是使用区，一个是空闲区
>>>新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作
当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区
当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理

老生代就是标记清除算法

###　　26.浏览器 JS运行
参见掘金收藏

###    27.position的值
1. absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。
2. fixed 生成固定定位的元素，相对于浏览器窗口进行定位（老IE不支持）。
3. relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。
4. static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
5. inherit 规定从父元素继承 position 属性的值。    
   
### 28.如何证明js是单线程的
- setTimeout()的回调函数是在主线程执行的
- 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行

#### 为什么js要设计成单线程语言
有他的用途决定的，如果在一个线程上删除了某个dom元素，另一个线程上对样式进行了修改，就会发生bug


### 29.什么是闭包？闭包的作用
闭包是指有权访问另一个函数作用域中变量的函数
>个人理解：上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放 
闭包变量存储在堆内存中

- 延长了局部变量的生命周期
- 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

        for(var i = 0; i<10; i++){
        (function(j){
            setTimeout(function(){
                console.log(j)
            }, 1000) 
          })(i)
        }

#### 闭包的生命周期
- 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)
- 死亡: 在嵌套的内部函数成为垃圾对象时

容易造成内存泄漏

### 30.new操作符做了哪些事情
new 创建对象实例

1. 新建一个空对象
2. 链接原型
3. 绑定this
4. 根据构建函数返回类型做判断，如果是原始值则忽略，返回对象则正常处理
5. 
        function myNew(Fun,...args){
                //创建新对象
                let obj ={}
                //把新对象的原型指针指向构造函数的原型属性
                obj.__proto__ = Fun.prototype
                //改变this指向
                let res = Fun.apply(obj,args)
                 //判断类型
                return res instanceof Object ? res : obj
        }

### 31.深拷贝和浅拷贝
- 深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象（新旧对象不共享同一块内存）,且修改新对象不会影响原对
- 如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址（新旧对象共享同一块内存），所以如果其中一个对象改变了这个地址，就会影响到另一个对象

如何实现深拷贝
- JSON.parse(JSON.stringify())
  
        let obj2 = JSON.parse(JSON.stringify(obj1));
- loadsh
- 手写，for in 遍历对象，逐个拷贝值

### 32.for in 和 for of
- for of 遍历的是值，for in 遍历的是key
- for of 适用于遍历数组/字符串/map/set等拥有迭代器对象的集合
- for in 主要遍历对象

### 33.事件委托（事件代理）
>事件委托，也叫事件代理，就是把原本要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务，原理是DOM元素的事件冒泡  只使用一个事件处理程序来管理一种类型的事件
>优点是减少内存占用，新增子对象的时候不用再重新绑定

事件流的三个阶段 事件流描述了页面接收事件的顺序
>1. 捕获阶段
>2. 目标阶段
>3. 冒泡阶段


### 34.建立一个没有原型的对象
  Object.create(null)

###　35.cookie，localStorage和sessionStorage

生命周期：

- cookie，默认关闭浏览器后失效，可以设置失效事件
- local，除非手动清楚，否则永远保存
- session，仅在当前网页会话下有效，关闭当前页面或者浏览器后就会被清除

存放数据大小：

- cookie 4kb
- 5m左右

http请求：

- cookie每次都会携带到请求头中
- 后两者不参与服务器通信

###　36.防抖和节流

防抖是多次事件只触发最后一次，节流是一定时间间隔内只触发一次

```javascript
function debounce (fn,delay){
	let timer
    return function(){
		if(timer) clearTimeout(timer)
    timer = setTimeout(()=>{
		fn.apply(this,arguments)
    },delay)    
}
```

```javascript
function throttle (fn,delay){
    //设置一个标志 区别也就仅仅在于标志了
	let flag = true
    return function(){
		if(!flag) return
       flag = false
        timer = setTimeout(()=>{
            fn.apply(this,arguments)
            flag = true
        },delay)
}
```



### 37.link和import

- link是html的标签，import是由css提供的一种引入样式的方式，link也不只可以用来引css
- 页面加载时，link引入的css会同时加载，import引入的会等到页面全部加载完毕之后再加载
- link兼容性好

### 38.浏览器缓存

> 浏览器可以缓存一些静态资源，如果没有缓存的话，每一次网络请求都要加载大量的图片和资源，会使页面加载慢很多，缓存的目的就是减少网络请求的体积和数量

1. 强制缓存就是文件直接从本地缓存中获取，不需要通过请求从网络获取。初次请求时，客户端会向服务端发起请求，服务器接收到请求后，返回一个cache-control和资源，catch设置了缓存的最大过期事件。在过期之前，当客户端再次发送请求时，会先检查有无过期，没有过期的话就会直接从本地缓存获取资源，此时状态是200（不问不说）。过期之后，就需要重新发起请求了

2. 协商缓存是一种服务端的缓存策略。如果客户端是第一次向服务器发送请求，则服务器返回资源和对应的资源标识给浏览器。该资源标识就是对当前返回资源的唯一标识，可以是etag或last-modified。之后再次发送请求时，就会带上这个标识，服务端进行校验，没有变化则返回304，否则返回200和新的资源

​	先强缓存，后协商，区别在于协商需要发送请求，强不需要

### 39.通过索引修改数组会渲染么（修改数组长度时）

 不会，可以使用Vue.set直接改变数组值

### 40.get和post

get是从服务器获取指定的资源，安全、幂等，可被缓存的

post根据报文对指定资源做出处理，不安全不幂等

get也可以带body，理论上所有的请求都可以带body。

put和post的区别，就是put修改内容，但不会增加数据的种类，post会改变数据的种类资源