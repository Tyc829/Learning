### 1、position都有些什么属性，具体说一下每个属性
  >- static：静态定位，表示无论怎么设置top、bottom、right、left属性元素的位置（与外部位置）都不会发生改变
  >- fixed：相对于浏览器窗口进行定位，同样是使用top、bottom、right、left
  >- relative：相对定位，表示用top、bottom、right、left属性可以设置元素相对与其相对于初始位置的相对位置
  >- absolute：绝对定位，表示用top、bottom、right、left属性可以设置元素相对于其父元素（除了设置了static的父元素以外）左上角的位置，如果父元素设置了static，子元素会继续追溯到祖辈元素一直到body
  （即一直找祖先，直到找到第一个positon不是默认值的祖先元素）

### 2.flex布局，都有什么属性
>flex-direction  属性设置容器主轴的方向
flex-wrap 用于设置当项目在容器中一行无法显示的时候如何处理  
flew-flow flex-flow属性是flex-deriction和flex-wrap属性的简写，默认值为[row nowrap]
justify-content justify-content属性用于设置项目在容器中的对齐方式
align-items align-items定义了项目在交叉轴上是如何对齐显示的
align-content 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用
##### 以下六个属性设置在子元素上
>- order 定义项目的排列顺序。数值越小，排列越靠前，默认为0
- flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大
- flex-shrink 属性定义了项目的缩小比例，默认为1
- flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。 默认auto
- flex flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选  flex:1 就是grow1,会填充空间,其余默认
- align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。          
#### 3css画三角形的原理

  首先创建一个div元素，设置div的width和height为0，只用边框宽来填充，边框样式设置为实线“solid”；然后顶部边框设置颜色，剩下的三个边框的颜色设置为透明“transparent”值即可

      `.trangle{

    　　width: 0px;

    　　height: 0px;

    　　border-top: 100px solid red;

    　　border-left: 100px solid transparent;

    　　border-right: 100px solid transparent;

    }

    <div class="trangle"></div>`

### 4.跨域
>所谓同源是指"协议+域名+端口"三者相同
跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了
##### 1.CORS
>CORS 需要浏览器和后端同时支持
服务端设置 Access-Control-Allow-Origin 就可以开启 CORS

##### 2.代理
实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤

>接受客户端请求 。
将请求 转发给服务器。
拿到服务器 响应 数据。
将 响应 转发给客户端。

##### 3.JSONP
>利用 script标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据
>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击

### 5.let const 和var
##### var

>var用于声明一个函数范围或者全局范围的变量
>var的所声明的变量并不是声明在块级作用域中 ，而是声明在最近的函数上下文中，也就是局部函数作用域。对于未在任何函数中声明的变量，其声明范围则是在全局对象global之中
>var的变量声明支持在同一作用域中进行同一个变量的多次重复的声明
>var的变量声明存在“提升”（hoisting）的特性
>变量的声明在执行时被提升了，但是，变量声明中的初始赋值操作却并没有被提升

##### let const

>带来我们的第一个让人兴奋的特性就是块级作用域
>不可重复声明
>暂时性死区 在代码执行上约束了变量必须遵循“声明后才能使用”的原则

##### let和const的区别
简单来说，let和const的区别在于，let用于声明基于块级作用域的变量，而const用于声明基于块级作用域的常量。

>使用let声明的变量，在变量的整个生命周期中，能够对变量随时进行赋值修改。
>使用const声明的变量为引用常量，必须在声明的同时进行初始赋值，在变量的整个生命周期中，无法再通过赋值的方式来修改变量值。

const的这个无法再赋值的特性，在不同的变量类型下会有不同的表现：

>1.如果const声明并且初始化赋值是基础数据类型变量（String、Number、Boolean、Symbol），那么该变量之后就不能再进行任何值的修改了。因为基础数据类型变量的值必须通过变量赋值来进行修改。
>2.如果const声明并且初始化赋值是引用数据类型变量（Array、Object、Map、Set），那么我们则可以随意对该变量的字段属性进行修改。因为引用数据类型变量的内容修改（新增、修改、删除属性）并不会出现所声明变量的赋值操作.

### 6.箭头函数
>1.声明一个普通函数需要使用关键字function来完成，并且使用function既可以声明成一个具名函数也可以声明成一个匿名函数
>2.声明一个箭头函数则只需要使用箭头就可以，无需使用关键字function，比普通函数声明更简洁。
>3.箭头函数只能声明成匿名函数，但可以通过表达式的方式让箭头函数具名

- 箭头函数没有自己的this，而是引用的上层作用域中this
- 箭头函数的this永远不会变，call、apply、bind也无法改变
>我们可以用call、apply、bind来改变普通函数的this指向，但是由于箭头函数的this指向在它定义时就已经确定了，永远指向它定义时的上层作用域中的this，所以使用这些方法永远也改变不了箭头函数this的指向

- 箭头函数没有原型prototype

- 箭头函数不能当成一个构造函数
  1. 新建一个空对象

  2. 链接到原型

  3. 绑定this，执行构造函数

  4. 返回新对象


          function myNew() {
          // 1.新建一个空对象
          let obj = {}
          // 2.获得构造函数
          let con = arguments.__proto__.constructor
          // 3.链接原型
          obj.__proto__ = con.prototype
          // 4.绑定this，执行构造函数
          let res = con.apply(obj, arguments)
          // 5.返回新对象
          return typeof res === 'object' ? res : obj
          }


### 7.margin塌陷问题如何解决，BFC，如何触发BFC
>块的上外边距(margin-top)和下外边距(margin-bottom)有时合并(折叠)为单个边距，其大小为单个边距的最大值(或如果它们相等，则仅为其中一个)，这种行为称为外边距折叠。

作用：两栏布局，清楚内部浮动，解决margn塌陷

##### 如何计算
>+ 同正或同负，取绝对值最大的
>+ 不同符号，取最大与最小值之和 70px + (-20px)

##### BFC，如何触发BFC
>BFC 全称：Block Formatting Context， 名为 "块级格式化上下文"
>简单来说就是，BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局

##### 触发BFC

- 根元素（html）
- 浮动元素（float 值不为 none）
- 绝对定位元素（position 值为 absolute 或 fixed）
- 行内块元素（display 值为 inline-block）
- 表格单元格（display 值为 table-cell，HTML 表格单元格默认值）
- 表格标题（display 值为 table-caption，HTML 表格标题默认值）
- 匿名表格单元格元素（display 值为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、tr、tbody、thead、tfoot 的默认值）或 inline-table）
- overflow 值不为 visible、clip 的块元素
- display 值为 flow-root 的元素
- contain 值为 layout、content 或 paint 的元素
- 弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器
- 网格元素（display 值为 grid 或 inline-grid 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器
- 多列容器（column-count 或 column-width (en-US) 值不为 auto，包括column-count 为 1）
- column-span 值为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中 (规范变更, Chrome bug)

### 8.那些属性可以继承呢
字体系列

>font
font-family
font-weight
font-size
font-style
font-variant: small-caps; 所有小写字母转成大写字母，但是与其他文本相比尺寸更小



文本系列

>text-indent
text-align
line-height
word-spacing
letter-spacing: 字符间距
text-transform: capitalize; 转大写 lowercase; 转小写
direction：文字方向
color



元素可见性

>visibility



表格布局

>border-collapse
border-spacing
empty-cell



列表布局

>list-style-type
list-style-image
list-style-position
list-style

### 9.有哪些选择器，优先级如何
- id选择器
- 类选择器
- 标签选择器
- 通配符
- 后代选择器  定义的时候用空格隔开
  
      .div1 p{
                color:red;
            }
- 伪类选择器
- 伪元素选择器
- 交集选择器  必须是h3标签，然后必须是special标签
- 并集选择器  三种基本选择器都可以放进来
- E:nth-child(n) E:first-child E:last-child
- 前三个（-n+3） 3到6 E:nth-child(-n+6):nth-child(n+3)
 

##### 优先级
!important>行内样式>id选择器>class、属性、伪类>标签、伪元素>通配符

### 10、设置宽度的width：50%是相对于谁而言，font-size:10%相对谁而言？
1.相对于父元素 2.相对于父节点的字体大小的相对大小

#### 11.px,em,rem
>px就是像素，也是我们现在经常使用的基本单位
>em参考物是当前标签的font-size，默认字体大小是16px，所以1em不是固定值，为什么大多数情况下都说是父元素的font-size，是因为多数情况下字体大小都是从父元素继承，如果给当前标签设置一个单独的font-size，em就会改变
rem相对于根元素的大小 一般浏览器默认是16px，所以1rem往往就是16px

### 13.判断数组的方法
Array.isArray()，instanceof,Object.prototype.toString.call()
>每一个继承Object的对象都有toString方法，如果toString方法没有重写的话，会返回[Object type],其中type为对象的类型，但当除了Object类型的对象外，其他类型直接使用toString方法时，会直接返回都是内容的字符串，所以需要使用call或者apply方法来改变toString方法的执行上下文。对于所有基本的数据类型都能进行判断，即使是null和undefined.

### 14.什么是伪数组？如何转化为真正的数组？
1. 具有length属性，可以获取长度。
2. 具有索引，可以通过遍历获取所有元素。
3. 不可以使用数组的内置方法和属性。

>伪数组的__proto__指向的是一个Object对象
真数组的__proto__指向的是一个Array数组
自然就不能使用数组的的方法

##### 常见的伪数组
1. 函数的内置对象arguments，它是所有实参组成的伪数组。
2. DOM对象组成的伪数组，通过document.querySelectorAll等获得的dom对象列表。

如何转化
1. 最简单的，先准备一个新的空数组，然后遍历伪数组，将伪数组中的值通过索引逐个添加到新数组当中
2. 利用扩展运算符(...)将伪数组转化为真数组 - ES6语法

        let divs = document.querySelectorAll('div');
        let arr = [...divs];

3. 利用Array的原型对象的slice方法，配合call()方法修改slice中this指向
   
        let arr = [].slice.call(divs);
4. 利用Array.from方法 - ES6

        let arr = Array.from(divs);

### 15.事件绑定的三种方式
1. 在DOM中绑定
2. 在JS代码中绑定 document.getElementById("demo").onclick=function(){}
3. 通过事件监听函数绑定
   
        document.getElementById(元素id).addEventListener("click", function(){
                        console.log("目标元素被点击了");
        });

#### addeventlistener几个参数，第三个参数什么意思
3个，第一个是事件名称，字符串，必填 onclick keyup keydown
第二个是执行函数，会传入一个事件参数，可以用event接收 click对应MouseEvent事件
第三个是触发类型 布尔值   true 捕获阶段执行 冒泡阶段执行 默认false 也可以传递一个对象

addEventListener可以对同一个元素绑定多个事件，执行顺序按照绑定时的顺序，从上到下依次执行。而onclick同一个元素只能绑定一个事件，如有多个，后面的事件会覆盖前面的事件。
注册addEventListener事件时不需要写on，而onclick方式则必须加on
在移除事件上，onclick使用的是指针指向null，例如document.onclick = null，而addEventListener则使用的是独有的移除方法removeEventListener

###    16.js基本数据类型
 Number，布尔，null，string，symbol（符号），undefined

typeof可以判断除null以外的所有基本类型（null）是对象  数组和对象是object ，函数是function
Object.prototype.toString.call


###    17.null和undefine区别
- 都是基本数据类型，都只有一个值
- 前者表示空对象，后者表示为定义
- 一般变量声明了但是没有定义会返回undefined，null可以用来初始化
- typeof null 会返回对象
- 双等号返回true 三等号返回false

null+1 = 1
undefined+1 = nan

###  18.typeof NaN 返回number

###  19.判断浏览器类型操作系统
- 代理检测
- navigator.userAgent 可以检查

### 20.HTTP状态码（小林背常见的）

### 21.样式选择器有哪几种
- 标签选择器
- 类选择器 .
- id选择器 #
- 派生选择器 div h1 嵌套关系
- 组合选择器 多种标签类id有相同的样式

### 22.从输入URL到页面加载发生什么

1. 解析URL 分析需要使用的传输协议和请求资源的路径等等
2. 判断缓存 如果缓存中存在请求的资源，那么就会直接返回，否则就要向服务器发送请求
3. 进行DNS解析，将URL解析为IP地址
4. TCP三次握手建立连接
5. 发送HTTP请求
6. 服务端接收HTTP请求并根据请求做出响应
7. 浏览器渲染页面
8. 四次挥手断开连接


### 23.解析html过程中遇到静态资源请求会不会阻塞？
会，浏览器有最高并发限制，请求过多就会引起阻塞

### 24.Css树会影响页面渲染的速度吗？
不会影响dom树的解析，但会影响dom树的渲染
详情看浏览器的渲染

### 25.浏览器的渲染
>HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)根据Render Tree渲染绘制，将像素渲染到屏幕上
>>DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。
然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。
>>>由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。

1. js在任何时候都会阻塞dom,通常是将js放在body结束的时候，这样会将所页面渲染完成之后再执行js。有利于用户的体验。async是异步加载js，加载完成立刻执行。defer是异步加载js，但是加载完成之后会等待一个事件dom解析完成之后执行。
2. css的加载会阻塞js的执行，会阻塞页面的渲染，但是不会阻塞DOM的解析。


### 26.浏览器的垃圾回收
1. 为什么需要垃圾回收
程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃

2. 垃圾回收策略
    >标记清除：此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁
    1. 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
    2. 然后从各个根对象开始遍历，把不是垃圾的节点改成1
    3. 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
    4. 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

    标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题  而且分配速度慢


    标记整理：标记升级的改进，在标记结束之后，会将活着的对象向内存的一端移动，最后清理道边界的内存


    引用计数：
    >跟踪记录每个变量值被使用的次数
    1. 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
    2. 如果同一个值又被赋给另一个变量，那么引用数加 1
    3. 如果该变量的值被其他的值覆盖了，则引用次数减 1
    4. 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存
    缺点，循环引用不会被清除
    标记清除需要每隔一段事件进行一次

##### V8的垃圾回收原理
>>V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收
新生代区域将堆内存一分为二，一个是使用区，一个是空闲区
>>>新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作
当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区
当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理

老生代就是标记清除算法

###　　26.浏览器 JS运行
参见掘金收藏

###    27.position的值
1. absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。
2. fixed 生成固定定位的元素，相对于浏览器窗口进行定位（老IE不支持）。
3. relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。
4. static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
5. inherit 规定从父元素继承 position 属性的值。    